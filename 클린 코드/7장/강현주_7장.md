## 7장 오류 처리

- 상당수 코드 기반은 전적으로 오류 처리에 좌우된다.
- 여기저기 픝어진 오류 처리코드 때문에 실제 코드가 하는 일을 파악하기가 거의 불가능한 경우
- 오류 처리 코드로 인해 프로그램 논리를 이해하기 어려워진다면 깨끗한 코드라 부르기 어렵다.
- 깨끗한 코드는 읽기도 좋아야 하지만 안정성도 높아야 한다.
- 오류 처리를 프로그램 논리와 분리해 독자적 사안으로 고려하면 깨끗한 코드를 작성할 수 있을 뿐만 아니라 프로그램의 안정성과 유지보수성도 크게 높아진다.

***

### 1. 오류 코드보다 예외를 사용하라

- 오류 코드를 사용하면 코드가 복잡해진다.
- Why? 오류 코드를 Enum 등으로 따로 관리해야 하기 때문에 의존성이 증가하고, 함수를 호출한 즉시 오류를 확인해야 한다.

***

### 2. Try-Catch-Finally 문부터 작성하라

- 예외가 발생할 코드를 짤 때는 try-catch-finally 문으로 시작하는 편이 낫다.
- try 블록에 들어가는 코드를 실행하면 어느 시점에서든 실행이 중단된 후 catch 블록으로 이동
- try 블록에서 무슨 일이 생기든지 호출자가 기대하는 상태를 정의하기 쉬워진다.
- catch 블록에서는 예외 유형을 좁히는 것을 권장한다.
- 강제로 예외를 일으키는 테스트 케이스를 작성한 후 테스트를 통과하게 코드를 작성하자.

***

### 3. 미확인 예외를 사용하라

- 안정적인 소프트웨어를 제작하는 요소로 확인된 예외가 반드시 필요하지는 않다.
- 예외 처리가 확인된 오류가 치르는 비용에 상응하는 이익을 제공하는지 생각해보자.

<br/>

- 확인된 예외는 OCP 를 위반한다.
- OCP (개방폐쇄원칙) : 기븡추가/변경 시 이미 제대로 동작하고 있던 코드를 변경하지 않아도 기존 코드에 새로운 코드를 추가하는 것만으로 기능 추가, 변경이 가능
- 하위 단계에서 예외를 던지면 선언부에 throws 절을 추가하고 상위 단계 메서드에서도 항상 해당 예외를 정의해야 한다. 예외가 추가/변경될 때마다 항상 최하위 단계에서 최상위 단계까지 연쇄적인 수정
- 모듈과 관련된 코드가 전혀 바뀌지 않았더라도 선언부가 바뀌었으므로 모듈을 다시 빌드, 배포해야 한다.
- 또한 모든 함수가 최하위 함수에서 던지는 예외를 알아야 하므로 캡슐화가 깨진다.

***

### 4. 예외에 의미를 제공하라

- 예외를 던질 때는 전후 상황을 충분히 덧붙여야 오류가 발생한 원인과 위치를 찾기 쉽다.
- 오류 메시지에 정보를 담아 예외와 함께 던진다.

***

### 5. 호출자를 고려해 예외 클래스를 정의하라

- 애플리케이션에서 오류를 정의할 때 프로그래머에게 가장 중요한 관심사는 오류를 잡아내는 방법
- 대다수 상황에서 우리가 오류를 처리하는 방식은 오류를 일으킨 원인과 무관하게 비교적 일정
- 외부 라이브러리의 API 에서 발생하는 예외를 처리할 경우 외부 API 를 감싸면 외부 라이브러리와 프로그램 사이에서 의존성이 줄어든다.

***

### 6. 정상 흐름을 정의하라

- 비즈니스 논리와 오류 처리가 잘 분리된 코드
- 예외로 처리할 생각보다는 정상 흐름 안에서 특수 사례를 처리하는 방식을 고민한다.

***

### 7. null을 반환하지 마라

- null 을 반환하는 코드는 호출자에게 문제를 떠넘기며, 한 줄 건너 하나씩 null을 확인하는 코드로 가득한 애플리케이션을 만들게 한다.
- null 확인이 너무 많은 것도 문제이다.
- 메서드에서 null을 반환하는 대신 예외를 던지거나 특수 사례 객체를 반환
- 사용하려는 외부 API가 null을 반환한다면 감싸기 메서드를 구현해 예외를 던지거나 특수 사례 객체를 반환

***

### 8. null을 전달하지 마라

- 정상적인 인수로 null을 기대하는 API가 아니라면 메서드로 null을 전달하는 코드는 최대한 피한다.


