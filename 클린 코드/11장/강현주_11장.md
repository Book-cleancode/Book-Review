## 11장 시스템

- 복잡성은 죽음이다. 개발자에게서 생기를 앗아가며, 제품을 계획하고 제작하고 테스트하기 어렵게 만든다.
- 시스템 수준에서도 깨끗함을 유지하는 방법 (추상화 + 모듈화)

***

### 1. 시스템 제작과 시스템 사용을 분리하라

- 관심사 분리
- 애플리케이션 객체를 제작하고 의존성을 서로 연결하는 준비과정 + 준비과정 이후에 이어지는 런타임 로직
- 모듈성 저조, 중복 심각
- 초기화 지연(계산 지연) 
```
if (service == null)
  service = new MyServiceImpl(?);
return service
```
- 실제로 필요할 때까지 객체를 생성하지 않는다. --> 불필요한 부하X --> 애플리케이션 시작시간 단축
- BUT...
> - getService 메서드가 MyServiceImpl과 생성자 인수에 명시적으로 의존 (MyServiceImpl을 실제 로직에서 전혀 사용하지 않더라도 의존성을 해결하지 않으면 컴파일 불가)
> - 테스트 시 MyServiceImpl 이 무거운 객체라면 테스트 전용 객체를 할당해야 함
> - 단일책임원칙 위베 : 일반 런타임 로직에 객체 생성 로직을 섞어놓은 탓에 모든 실행 경로도 테스트해야 함 (service가 null, not null)
> - MyServiceImpl 이 모든 상황에 적합한 객체인지 모른다
- 설정 논리는 (일관적인 방식으로) 일반 실행 논리와 분리해야 모듈성이 높아진다.

#### Main 분리
- 생성과 관련한 코드는 모두 main이나 main이 호출하는 모듈로 옮기고, 나머지 시스템은 모든 객체가 생성되었고 모든 의존성이 연결되었다고 가정
- main 함수에서 시스템에 필요한 객체를 생성한 후 이를 애플리케이션에 넘긴다. 애플리케이션은 객체를 사용할 뿐
- main 함수와 애플리케이션 사이의 의존성 화살표 방향은 항상 main에서 애플리케이션 쪽으로
- 애플리케이션은 main이나 객체가 생성되는 과정을 전혀 모른다.

#### 팩토리
- 객체가 생성되는 시점을 애플리케이션이 결정할 필요가 있을 경우
- 생성 시점은 애플리케이션이 결정, 생성 코드는 모르게
- main 함수와 애플리케이션 사이의 의존성 화살표 방향은 항상 main에서 애플리케이션 쪽으로

#### 의존성 주입(DI)
- 제어 역전
- 한 객체가 맡은 보조 책임을 새로운 객체에게 전적으로 떠넘긴다.
- 새로운 객체는 넘겨받은 책임만 맡으므로 단일 책임 원칙에 부팝
- 객체는 의존성 자체를 인스턴스로 만드는 책임은 지지 않고, 다른 전담 메커니즘에 책임을 넘겨 제어를 역전
- 초기 설정의 경우 시스템 전체에서 필요하므로 책임질 메커니즘으로 main 루틴이나 특수 컨테이너를 사용
```
MyServiceImpl myService = (MyService)(jndiContext.lookup("NameOfMySerivce"));
```
- 반환되는 객체가 적절한 인터페이스를 구현하는 한 실제로 반환되는 객체의 유형을 제어하지 않는다.
- DI컨테이너는 요청이 들어올 때마다 필요한 객체의 인스턴스를 만든 후 생성자 인수나 설정자 메서드를 사용해 의존성을 설정
- 실제로 생성되는 객체 유형은 설정 파일 또는 특수 생성 모듈에서 코드로 명시
- 스프링 프레임워크
- 대다수 DI컨테이너는 필요할 때까지는 객체를 생성하지 않고, 계산 지연이나 비슷한 최적화에 쓸 수 있도록 팩토리를 호출하거나 프록시를 생성하는 방법을 제공

***

### 2. 확장

- 처음부터 올바르게 시스템을 만들 수 있다는 믿음은 미신.
- 주어진 사용자 스토리에 맞춰 시스템을 구현하고, 새로운 스토리가 들어올 경우 그에 맞춰 시스템을 조정하고 확장
- 반복적이고 점진적인 애자일 방식
- 시스템 수준에서도 마찬가지

#### 횡단 관심사
- 영속성
> - 한 객체가 자신을 생성한 작업이 종료되었음에도 불구하고 지속적으로 존재하는 상태
> - 데이터를 생성한 프로그램의 실행이 종료되더라도 사라지지 않는 것
> - 마이바티스 : 자료를 데이터베이스에 저장하는 과정을 도와주고 자동화
- 영속성과 같은 관심사를 구현할 시 모든 객체가 전반적으로 동일한 방식을 이용하게 구현
- 특정 DBMS나 독자적인 파일을 사용, 데이블과 열은 같은 명명관례로, 트랜잭션 의미 일관 등
- 원론적으로는 모듈화되고 캡슐화된 방식으로 영속성 방식을 구상 가능
- BUT 현실적으로는 영속성 방식을 구현한 코드가 온갖 객체로 흩어진다 --> 횡단 관심사

#### 관점 지향 프로그래밍 (AOP)
- 횡단 관심사에 대처해 모듈성을 확보하는 방법론
- 관점 : 특정 관심사를 지원하려면 시스템에서 특정 지점들이 동작하는 방식을 일관성 있게 바꿔야 한다는 모듈 구성 개념
- 프로그래머는 영속적으로 저장할 객체와 속성을 선언한 후 영속성 책임을 영속성 프레임워크에 위임
- AOP프레임워크는 대상 코드에 영향을 미치지 않는 상태로 동작 방식을 변경

#### 자바 프록시


