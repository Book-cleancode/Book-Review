## 3장 함수

- 함수 : 프로그램의 가장 기본적인 단위
- 의도를 분명히 표현하는 함수가 좋은 함수

**1. 작게 만들어라**
- 얼마나 짧아야 좋을까? 2줄, 3줄, 4줄짜리 함수도 가능
- 블록과 들여쓰기 : if문/else문/while문에 들어가는 블록은 한 줄이어야 한다. 대개 거기서 함수를 호출. 함수에서 들여쓰기 수준은 1단이나 2단을 넘어서면 안 된다.

***

**2. 한 가지만 해라**
- 지정된 함수 이름 아래에서 추상화 수준이 하나인 단계만 수행한다면 그 함수는 한 가지 작업만 한다.
- 우리가 함수를 만드는 이유 : 큰 개념(함수 이름)을 다음 추상화 수준에서 여러 단계로 나눠 수행하기 위해서
- 의미있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 하는 것
- 함수 내 섹션 : 한 가지 작업만 하는 함수는 자연스럽게 섹션으로 나누기 어렵다.

***

**3. 함수 당 추상화 수준은 하나로**
- 함수가 한 가지 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야 함
- 추상화 수준 높음 : getHtml()
- 추상화 수준 중간 : String pagePathName = PathParser.render(pagepath);
- 추상화 수준 낮음 : append("\n")
- 위애서 아래로 코드 읽기 (내려가기 규칙) : 코드는 위에서 아래로 이야기처럼 읽혀야 좋다. 한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 온다.

***

**4. Switch문**
- switch문은 작에 만들기 어렵다. case분기가 단 두개인 switch문도 너무 길다.
- 본질적으로 switch문은 N가지를 처리
- 다형성을 이용하여 switch문을 저차원 클래스에 숨기고 절대로 반복하지 않는 방법
- 책 47 ~ 48 소스 참고

***

**5. 서술적인 이름을 사용하라**
- 함수가 하는 일을 잘 표현하는 이름이 좋은 이름
- 함수가 작고 단순할수록 서술적인 이름을 고르기도 쉽다
- 길고 서술적인 이름이 길고 서술적인 주석보다 좋다
- 일관성 : 모듈 내에서 함수 이름은 같은 문구, 명사, 동사를 사용

***

**6. 함수 인수**
- 함수에서 이상적인 인수 개수는 0개 (무항)
- 1개 > 2개 > 3개부터는 가능한 피하자
- 추상화 수준을 고려하여 함수를 읽는 사람이 현 시점에서 고려하지 않아도 되는 세부사항은 인수로 넘기지 않고 다음 함수에서 선언하는 편이 좋다.
- 테스트 관점에서도 인수가 너무 많으면 인수를 조합하여 테스트 케이스가 많아져 함수를 검증하기 어렵다.
- 출력 인수 : 되도록 사용하지 말자. 반환값을 받자.

> - 많이 쓰는 단항 형식
> - 인수에 질문을 던지는 경우
> - boolean fileExists("MyFile")
> - 인수를 뭔가로 변환해 결과를 반환하는 경우
> - InputStream fileOpen("MyFile")
> - 이벤트 : 입력 인수만 있고 출력 인수는 없음
> - passwordAttemptFailedNtimes(int attempts)

> - 플래그 인수
> - 사용하지 말자.
> - 함수가 한꺼번에 여러 가지를 처리하는 셈 : 참이면 이걸 하고 거짓이면 저걸 한다.

> - 이항 함수
> - 불가피한 경우를 제외하고 가능하면 단항 함수로
> - 인수 2개가 적절한 경우 : 인수 2개가 한 값을 표현하는 두 요소 일 때, 두 요소에 자연적인 순서가 있을 때

> - 인수 객체
> - 인수가 2 ~ 3개 필요하다면 클래스 변수를 사용

> - 동사와 키워드
> - 단항 함수는 함수와 인수가 동사/명사 쌍을 이뤄야 함
> - writeField(name)

***

**7. 부수 효과를 일으키지 마라**
- 함수에서 한 가지를 하겠다고 약속한 후 남몰래 다른짓을 하지 말자
- checkPassword : 패스워드 검증만 해야 함. 세션 초기화 등을 하면 안 됨.
- 시간적인 결합을 초래 : 특정 상황에서만 호출 가능

***

**8. 명령과 조회를 분리하라**
- 함수는 뭔가를 수행하거나 뭔가에 답하거나 둘 중 하나만 해야 함
- 객체 상태를 변경하거나 객체 정보를 반환하거나

***

**9. 오류 코드보다 예외를 사용하라**
- 명령 함수에서 오류 코드를 반환하는 방식은 명령/조회 분리 규칙을 미묘하게 위반
- if (deletePage(page) == E_OK)
- 여러 단계로 중첩되는 코드를 야기. 오류 코드를 반환하면 호출자는 오류 코드를 곧바로 처리해야 한다는 문제
- Try/Catch 블록 : 별도 함수로 뽑아내자. 코드 구조에 혼란 + 정상 동작과 오류 처리 동작을 뒤섞으므로
- 오류 처리도 한 가지 작업이다 : 오류를 처리하는 함수는 오류만 처리해야 마땅
- 오류 코드를 반환한다는 이야기는 클래스든, 열거형 변수든, 어디선가 오류 코드를 정의한다는 뜻 --> 의존성 자석
- 의존성 자석 : 다른 클래스에서 Error enum을 import해 사용해야 하므로 Error enum이 변한다면 Error enum을 사용하는 클래스 전부를 다시 컴파일하고 다시 배치해야. Error enum 클래스의 변경이 어려워 짐.

***

**10. 반복하지 마라**
- 중복은 문제다.
- 코드 길이가 늘어날 뿐 아니라 알고리즘이 변하면 네 곳이나 손봐야 한다.
- 어느 한 곳이라도 빠뜨리면 오류 발생

***

**11. 구조적 프로그래밍**
- 모든 함수와 함수 내 모든 블록에 입구와 출구가 하나만 존재해야 한다.
- 루프 안에서 break, continue를 사용해선 안 되며, goto는 절대로 안 된다. (함수를 작게 만든다면 가능)
- 함수가 아주 클 때 이익 제공

***

**12. 함수를 어떻게 짜죠?**
- 초안 --> 서투른 코드를 빠짐없이 테스트하는 단위 테스트 케이스 작성 --> 코드 다듬기 + 단위 테스트 통과
- 프로그래밍의 기술 = 언어 설계의 
